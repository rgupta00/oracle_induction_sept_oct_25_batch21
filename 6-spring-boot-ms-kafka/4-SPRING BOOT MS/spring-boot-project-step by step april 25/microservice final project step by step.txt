Spring boot microservice project step by step:
==============================================
Services		Port Numbers:		
------------------------------------
Product Service			8080
Order Service			8081
Inventory Service		8082
Notification Service	8083
gateway					9000
-------------------------------------

products
orders
inventroy
notifications


Product Service
================
CREATE PRODUCT	 	POST	/api/product/
READ ALL PRODUCTS	GET	  /api/product/

Step 1: choose dependencies:
---------------------
Lombok, Spring Web, Test Containers, Spring Data MongoDB

docker-compose.yml
---------------
version: '4'
services:
  mongodb:
    image: mongo:7.0.5
    container_name: mongodb
    ports:
      - "27018:27017"
    environment:
      MONGO_INITDB_DATABASE: product-service
#    volumes:
#      - ./data/mongodb:/data/db
  mysql:
    image: mysql:8.3.0
    container_name: mysql
    environment:
      MYSQL_ROOT_PASSWORD: mysql
    ports:
      - "3316:3306"
#    volumes:
#      - ./data/mysql:/var/lib/mysql
#      - ./docker/mysql/init.sql:/docker-entrypoint-initdb.d/init.sql



application.properties
-----------------------
spring.application.name=products
spring.data.mongodb.uri=mongodb://localhost:27018/product-service



Rest endpoints:
----------------
@Document(value = "product")
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
public class Product {

    @Id
    private String id;
    private String name;
    private String description;
    private BigDecimal price;
}

Dto:
----
public class ProductDto {

    private String id;
    private String name;
    private String description;
    private BigDecimal price;
}

convertion class
----------------------

public class ConvertUtil {
    public static Product toProduct(ProductDto productDto) {
        Product product = Product.builder()
        		.id(productDto.getId())
        		.name(productDto.getName())
        		.description(productDto.getDescription())
        		.price(productDto.getPrice())
        		.build();
        return product;

    }
    public static ProductDto toProductDto(Product product) {
        ProductDto productDto = ProductDto.builder()
        		.id(product.getId())
        		.name(product.getName())
        		.description(product.getDescription())
        		.price(product.getPrice())
        		.build();
        return productDto;

    }
}

repo:
----
public interface ProductRepo extends MongoRepository<Product, String> {
}

service layer:
--------------

public interface ProductService{
	public ProductDto createProduct(ProductDto productRequest);
	public List<ProductDto> getAllProducts();
}



@Service
@AllArgsConstructor
public class ProductServiceImpl implements ProductService{

    private final ProductRepo productRepository;
    @Override
    public ProductDto createProduct(ProductDto productRequest) {
        Product product= ConvertUtil.toProduct(productRequest);
        productRepository.save(product);
        return ConvertUtil.toProductDto(product);
    }

    @Override
    public List<ProductDto> getAllProducts() {
        return productRepository.findAll().stream()
                .map(ConvertUtil::toProductDto).toList();
    }
}


controller layer:
---------------
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public ProductDto createProduct(@RequestBody ProductDto productDto) {
       return productService.createProduct(productDto);
    }

    @GetMapping
    @ResponseStatus(HttpStatus.OK)
    public List<ProductDto> getAllProducts() {
        return productService.getAllProducts();
    }
}


spring.application.name=products
spring.data.mongodb.uri=mongodb://localhost:27018/product-service


Testing
---------
3 tier
rest assured
Test container dependencies:
-------------------------
       <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-testcontainers</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.testcontainers</groupId>
            <artifactId>mongodb</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>io.rest-assured</groupId>
            <artifactId>rest-assured</artifactId>
            <version>5.3.2</version>
        </dependency>
		
		
import static org.junit.jupiter.api.Assertions.*;

import com.orders.dto.ProductDto;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MongoDBContainer;

import java.math.BigDecimal;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class ProductControllerTest {

    @ServiceConnection
    static MongoDBContainer mongoDBContainer = new MongoDBContainer("mongo:7.0.7");

    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mongoDBContainer.start();
    }
    @Test
    void shouldCreateProduct() throws Exception {
        ProductDto productDto = getProductRequest();
        RestAssured.given()
                .contentType("application/json")
                .body(productDto)
                .when()
                .post("/api/products")
                .then()
                .log().all()
                .statusCode(201)
                .body("id", Matchers.notNullValue())
                .body("name", Matchers.equalTo(productDto.getName()))
                .body("description", Matchers.equalTo(productDto.getDescription()))
                .body("price", Matchers.is(productDto.getPrice().intValueExact()));
    }

    private ProductDto getProductRequest() {
        return new ProductDto("test", "test", new BigDecimal(1));
    }
}









Order service: 8081
======================
choose web, jpa, mysql, actuator, flyway migration

repo layer:
------------
@Entity
@Table(name = "t_orders")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String orderNumber;
    private String skuCode;
    private BigDecimal price;
    private Integer quantity;
}

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OrderDto {
    private Long id;
    private String orderNumber;
    private String skuCode;
    private BigDecimal price;
    private Integer quantity;
}



import com.orders.dto.OrderDto;
import com.orders.entities.Order;

public class ConversionUtil {

    public static  OrderDto  orderToOrderDto(com.orders.repo.Order order) {
        OrderDto orderDto = new OrderDto();
        orderDto.setId(order.getId());
        orderDto.setOrderNumber(order.getOrderNumber());
        orderDto.setSkuCode(order.getSkuCode());
        orderDto.setPrice(order.getPrice());
        orderDto.setQuantity(order.getQuantity());
        return orderDto;
    }
    public static Order orderDtoToOrder(OrderDto orderDto) {
        Order order = new Order();
        order.setId(orderDto.getId());
        order.setOrderNumber(orderDto.getOrderNumber());
        order.setSkuCode(orderDto.getSkuCode());
        order.setPrice(orderDto.getPrice());
        order.setQuantity(orderDto.getQuantity());
        return order;

    }
}


public interface OrderRepository extends JpaRepository<Order, Long> {
}

service layer:
-------------

public interface OrderService{
	 public OrderDto placeOrder(OrderDto orderDto);
}

@Service
@RequiredArgsConstructor
@Transactional
public class OrderServiceImpl implements OrderService {
    private final OrderRepository orderRepository;

    @Override
    public OrderDto placeOrder(OrderDto orderDto) {
        Order order = ConversionUtil.orderDtoToOrder(orderDto);
        orderRepository.save(order);
        return ConversionUtil.orderToOrderDto(order);
    }
}




controller layer:
--------------------

@RestController
@RequestMapping("/api/orders")
@RequiredArgsConstructor
public class OrderController {

    private final OrderService orderService;

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String placeOrder(@RequestBody OrderDto orderDto) {
        orderService.placeOrder(orderDto);
        return "Order Placed Successfully";
    }
}





Flyway DB migration:
------------------
		Flyway is a database migration tool that is commonly used with Spring Boot 
		to manage version control for your database schema. 
		
		It helps you evolve your database structure in a controlled and consistent way alongside your application code.

	What Flyway Does:
		Manages schema versioning.
		Applies incremental migrations to your database using SQL or Java-based scripts.
		Ensures that the database schema stays in sync with the application code.

	How It Works in Spring Boot:
		When you include Flyway in a Spring Boot application (by adding the Flyway dependency), it will:
		On application startup, check the current version of the database.
		Look for migration scripts in a specific location (default: classpath:db/migration).
		Apply any new migration scripts in order (based on filename versioning, e.g., V1__init.sql, V2__add_users.sql).
		Track applied migrations in a special table (by default flyway_schema_history).


db.migration
-----------

<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-core</artifactId>
		</dependency>
		<dependency>
			<groupId>org.flywaydb</groupId>
			<artifactId>flyway-mysql</artifactId>
		</dependency>
		

V1__init.sql
--------------
CREATE TABLE `t_orders`
(
    `id`          bigint(20) NOT NULL AUTO_INCREMENT,
    `order_number` varchar(255) DEFAULT NULL,
    `sku_code`  varchar(255),
    `price`    decimal(19, 2),
    `quantity` int(11),
    PRIMARY KEY (`id`)
);


application.properties
------------------
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3316/order_service?createDatabaseIfNotExist=true
spring.datasource.username=root
spring.datasource.password=mysql
spring.jpa.hibernate.ddl-auto=none
server.port=8081









Inventory service: 8082
======================

docker-compose.yml
--------------------
version: '4'
services:
  mysql:
    image: mysql:8.3.0
    container_name: mysql
    ports:
      - "3307:3306"
    environment:
      MYSQL_ROOT_PASSWORD: mysql
    volumes:
      - ./mysql/init.sql:/docker-entrypoint-initdb.d/init.sql
      - ./docker/mysql/data:/var/lib/mysql
	  
Note: create a folder mysql in root location and put 

init.sql
-------
CREATE DATABASE IF NOT EXISTS order_service;
CREATE DATABASE IF NOT EXISTS inventory_service;	


Repo layer:
-----------
@Entity
@Table(name = "t_inventory")
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class Inventory {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String skuCode;
    private Integer quantity;
}






public interface InventoryRepository extends JpaRepository<Inventory, Long> {
    boolean existsBySkuCodeAndQuantityIsGreaterThanEqual(String skuCode, int quantity);
}




service layer:
------------
public interface InventoryService{
	public boolean isInStock(String skuCode, Integer quantity) ;
}



@Service
public class InventoryServiceImpl implements InventoryService{

    private  InventoryRepository inventoryRepository;
    @Autowired
    public InventoryServiceImpl(InventoryRepository inventoryRepository) {
        this.inventoryRepository = inventoryRepository;
    }

    @Transactional(readOnly = true)
    public boolean isInStock(String skuCode, Integer quantity) {
        return inventoryRepository.existsBySkuCodeAndQuantityIsGreaterThanEqual(skuCode, quantity);
    }
}


controller layer:
--------------
@RestController
@RequestMapping("/api/inventory")
@RequiredArgsConstructor
public class InventoryController {

    private final InventoryService inventoryService;

    @GetMapping
    @ResponseStatus(HttpStatus.OK)
    public boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity) {
        return inventoryService.isInStock(skuCode, quantity);
    }
}



application.properties
-----------------------
spring.application.name=inventory
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3316/inventory_service?createDatabaseIfNotExist=true
spring.datasource.username=root
spring.datasource.password=root
spring.jpa.hibernate.ddl-auto=none
server.port=8082



db migration
-------------
https://stackoverflow.com/questions/53173291/flyway-cannot-find-migrations-location-in
----------


db.migration

V1__initial_schema.sql
------------------------
CREATE TABLE `t_inventory`
(
    `id`       bigint(20) NOT NULL AUTO_INCREMENT,
    `sku_code`  varchar(255) DEFAULT NULL,
    `quantity` int(11)      DEFAULT NULL,
    PRIMARY KEY (`id`)
);

V2__add_inventory.sql
--------------------
insert into t_inventory (quantity, sku_code)
values (100, 'iphone_15'),
       (100, 'pixel_8'),
       (100, 'galaxy_24'),
       (100, 'oneplus_12');
	   
	   




add restassure for testing:
-----------------------------
		<dependency>
			<groupId>io.rest-assured</groupId>
			<artifactId>rest-assured</artifactId>
			<version>5.3.2</version>
		</dependency>
  
spring boot testing:
--------------------

import com.jayway.jsonpath.JsonPath;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.Matchers.is;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class InventoryServiceApplicationTests {

    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldReadInventory() {
        var response = RestAssured.given()
                .when()
                .get("/api/inventory?skuCode=iphone_15&quantity=1")
                .then()
                .log().all()
                .statusCode(200)
                .extract().response().as(Boolean.class);
        assertTrue(response);

        var negativeResponse = RestAssured.given()
                .when()
                .get("/api/inventory?skuCode=iphone_15&quantity=1000")
                .then()
                .log().all()
                .statusCode(200)
                .extract().response().as(Boolean.class);
        assertFalse(negativeResponse);

    }

}



		
		











 Synchronous Communication between our Order Service and Inventory Service 
 using Spring Cloud OpenFeign
 ------------------------------
 
 step 0: @EnableFeignClients("com.orders.proxy")

 Step 1: put Spring Cloud OpenFeign in order service
 
step 2:
 @FeignClient(value = "inventory", url = "${inventory.url}")
public interface InventoryClient {
    @RequestMapping(method = RequestMethod.GET, value = "/api/inventory")
    boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity);
}

inventory.url=http://localhost:8082






Now use inventoryClient:
----------------

 @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String placeOrder(@RequestBody OrderDto orderDto) {
        boolean inStock = inventoryClient.isInStock(orderDto.getSkuCode(), orderDto.getQuantity());
        if (inStock) {
            orderService.placeOrder(orderDto);
        } else {
            throw new RuntimeException("Product with Skucode " + orderDto.getSkuCode() + "is not in stock");
        }
        
        return "Order Placed Successfully";
    }




RestAssured dependencies:
----------------------------

<dependency>
			<groupId>io.rest-assured</groupId>
			<artifactId>rest-assured</artifactId>
			<version>5.3.2</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-testcontainers</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.testcontainers</groupId>
			<artifactId>mysql</artifactId>
			<scope>test</scope>
		</dependency>

OrderControllerTest without wiremock:
----------------------------------

package com.orders.controller;
import com.orders.controller.sub.InventoryClientStub;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.cloud.contract.wiremock.AutoConfigureWireMock;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.MatcherAssert.assertThat;
import io.restassured.RestAssured;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MySQLContainer;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class OrderControllerTest {
    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldSubmitOrder() {
        String submitOrderJson = """
                {
                     "skuCode": "iphone_15",
                     "price": 1000,
                     "quantity": 1
                }
                """;
       
        var responseBodyString = RestAssured.given()
                .contentType("application/json")
                .body(submitOrderJson)
                .when()
                .post("/api/orders")
                .then()
                .log().all()
                .statusCode(201)
                .extract()
                .body().asString();

        assertThat(responseBodyString, Matchers.is("Order Placed Successfully"));
    }
}



Using wiremock:
-------------
 What if inventory service is down, or it is costly to call it as it is external service
 Now our Integration test no longer run successfully as we are calling the Inventory Service.

To make these test successful, we have to use a library called Wiremock that provides 
a mock server environment to test our Order Service by making some mock HTTP calls.

By using Wiremock, we can verify if our Order Service is calling the inventory 
service with correct URL Params/Request Body/ Path Variables or not.
 We can also stub the response and test how our service is responding for various scenarios.

To enable wiremock, we need to add the following
 dependency to our pom.xml file of Order Service

step 1:
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-contract-stub-runner</artifactId>
            <scope>test</scope>
        </dependency>
		

step 2: Apply AutoConfigureWireMock annotation on top of test class

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureWireMock(port = 0)
class OrderControllerTest {
}
	
step 3: create a stub in package com.orders.controller.sub in test branch

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
public class InventoryClientStub {
    public static void stubInventoryCall(String skuCode, Integer quantity) {
        stubFor(get(urlEqualTo("/api/inventory?skuCode=" + skuCode + "&quantity=" + quantity))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader("Content-Type", "application/json")
                        .withBody("true")));
    }
}

Step 4: call InventoryClientStub in our application

    @Test
    void shouldSubmitOrder() {
        String submitOrderJson = """
                {
                     "skuCode": "iphone_15",
                     "price": 1000,
                     "quantity": 1
                }
                """;
        //call inventory stubservice before actual test call
        InventoryClientStub.stubInventoryCall("iphone_15", 1);
		//.........
	}
	
step 5: create resources folder in the test (as we have in main branch)
and provide configuration for inventory.url
as we dont know what port wiremock will use thats why we have to use 

application.properties
inventory.url=http://localhost:${wiremock.server.port}



OrderControllerTest with wiremock:
----------------------------------

package com.orders.controller;
import com.orders.controller.sub.InventoryClientStub;
import io.restassured.RestAssured;
import org.hamcrest.Matchers;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.springframework.cloud.contract.wiremock.AutoConfigureWireMock;
import org.testcontainers.containers.MySQLContainer;

import static org.hamcrest.MatcherAssert.assertThat;
import io.restassured.RestAssured;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
import org.testcontainers.containers.MySQLContainer;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
//@AutoConfigureWireMock(port = 0)
class OrderControllerTest {
    @ServiceConnection
    static MySQLContainer mySQLContainer = new MySQLContainer("mysql:8.3.0");
    @LocalServerPort
    private Integer port;

    @BeforeEach
    void setup() {
        RestAssured.baseURI = "http://localhost";
        RestAssured.port = port;
    }

    static {
        mySQLContainer.start();
    }

    @Test
    void shouldSubmitOrder() {
        String submitOrderJson = """
                {
                     "skuCode": "iphone_15",
                     "price": 1000,
                     "quantity": 1
                }
                """;
        //call inventory stubservice before actual test call
        //InventoryClientStub.stubInventoryCall("iphone_15", 1);

        var responseBodyString = RestAssured.given()
                .contentType("application/json")
                .body(submitOrderJson)
                .when()
                .post("/api/orders")
                .then()
                .log().all()
                .statusCode(201)
                .extract()
                .body().asString();

        assertThat(responseBodyString, Matchers.is("Order Placed Successfully"));
    }
}



API gateway:
------------
step 1: choose api gateway, actuator
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway-mvc</artifactId>
		</dependency>
		
step 2:
define route:

@Configuration
public class Route {

    @Value("${product.service.url}")
    private String productServiceUrl;
	
    @Value("${order.service.url}")
    private String orderServiceUrl;
	
    @Value("${inventory.service.url}")
    private String inventoryServiceUrl;
	
    @Bean
    public RouterFunction<ServerResponse> productServiceRoute() {
        return GatewayRouterFunctions.route("product_service")
                .route(RequestPredicates.path("/api/products"), HandlerFunctions.http("http://localhost:8080"))
                .build();
    }
    @Bean
    public RouterFunction<ServerResponse> orderServiceRoute() {
        return GatewayRouterFunctions.route("order_service")
                .route(RequestPredicates.path("/api/orders"),
                        HandlerFunctions.http("http://localhost:8081"))
                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> inventoryServiceRoute() {
        return GatewayRouterFunctions.route("inventory_service")
                .route(RequestPredicates.path("/api/inventory"), HandlerFunctions.http("http://localhost:8082"))
                .build();
    }

}


application.properties

spring.application.name=gateway
server.port=9000
product.service.url=http://localhost:8080
order.service.url=http://localhost:8081
inventory.service.url=http://localhost:8082

#spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8181/realms/master
# Actuator Endpoints
management.health.circuitbreakers.enabled=true
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always




now check:
http://localhost:9000/api/inventory?skuCode=iphone_15&quantity=10




OAuth2:
======
What is oauth2?
	oauth2 is a protocol that allow a user to grant limited access to there resource on one site to another side
	without having to expose there credential
	
	https://oauth.net/about/introduction/






OAuth keyclock security on API gateway level (Client credential grant type):
------------------------------------------------------------------------------
step 1: docker compose 
  keycloak-mysql:
    container_name: keycloak-mysql
    image: mysql:8
    volumes:
      - ./volume-data/mysql_keycloak_data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: keycloak
      MYSQL_USER: keycloak
      MYSQL_PASSWORD: password
  keycloak:
    container_name: keycloak
    image: quay.io/keycloak/keycloak:24.0.1
    command: [ "start-dev", "--import-realm" ]
    environment:
      DB_VENDOR: MYSQL
      DB_ADDR: mysql
      DB_DATABASE: keycloak
      DB_USER: keycloak
      DB_PASSWORD: password
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    ports:
      - "8181:8080"
    volumes:
      - ./docker/keycloak/realms/:/opt/keycloak/data/import/
    depends_on:
      - keycloak-mysql
	  
	  
Step 2: start keycloak at 
http://localhost:8181/

login :admin/admin


What is relem?
-----------
	A realm manages a set of users, credentials, roles, and groups. 
	
	A user belongs to and logs into a realm. 
	
	Realms are isolated from one another and can only 
	manage and authenticate the users that they control.
	

step 3: 
create new relem "spring-ms-realm"

Note:Client Credentials Grant type
----------------------------------------
		OAuth 2.0 Client Credentials Grant type is used when a machine (client)
		needs to authenticate without a user context. 
		It's ideal for machine-to-machine (M2M) communication.

	Client Credentials Grant - Key Characteristics:
		No user involved – the client authenticates using its own credentials.
		The client obtains an access token to access resources on its own behalf.
		Commonly used in backend services, scheduled jobs, or API integrations.

Use Cases:
	Microservices Communication
		Service A (e.g., Order Service) calls Service B 
		(e.g., Inventory Service) directly using an access token.

	Scheduled Jobs / Daemons
		Background jobs or cron tasks accessing 
		APIs to perform system-level actions.

	Third-Party Integrations (Non-user specific)
		A payment gateway plugin retrieving an auth
		token to send batch invoices.

	Backend APIs Accessing Resources
		An internal dashboard querying an analytics API to 
		pull data for reports (not tied to a specific user).

	Example Flow:
		Client authenticates with client ID + secret to the auth server.
		Auth server returns an access token.
		Client uses the token to access protected resources.



step 3: register client application with keycloak server:
---------------------------------------------------
client -> create client -> openid connect

provide:
client id: busycoder-cc

client name: busycoder-cc-app

enable client authentication--->auth flow --> service accounts roles (other dont select)
				two application try to communicate each other
				
copy client secret:

client secret: Hdh1qlQYTYJNiwbiKmLioGZv4YQ2FYna




step 4: getting access token form auth server in client credential grant flow:
------------------------------------------------------------------------------

go to relem setting-->
					open endpoint section

http://localhost:8181/realms/spring-ms-realm/.well-known/openid-configuration



{
"issuer": "http://localhost:8181/realms/spring-ms-realm",
 .....
 .....
}

now copy
http://localhost:8181/realms/spring-ms-realm



and put in application.properties
----------------------------
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8181/realms/spring-ms-realm


put configuration in spring boot project:
-----------------------------
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
		</dependency>
		
		
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity.authorizeHttpRequests(authorize -> authorize
                        .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
                .build();
    }
}



Now if we want to access we will get 401
http://localhost:9000/api/products

Now how to access it?
------------------------
Select OAuth2 

http://localhost:8181/realms/spring-ms-realm/protocol/openid-connect/token

Configure new token:
----------------------
Token Name	:Token
Grant type : Client Credentials
Access Token URL : http://localhost:8181/realms/spring-ms-realm/protocol/openid-connect/token
Client ID: busycoder-cc
Client Secret: Hdh1qlQYTYJNiwbiKmLioGZv4YQ2FYna
Scope: openid roles

understand token formate










Swagger (OpenAPI documentation of Project)
--------------------------------------

Step 1: add dep in all projects
----------------------------------
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.5.0</version>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>2.5.0</version>
        </dependency>


Step 2: Configuration openapi customization
------------------------------------------
@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI productServiceAPI() {
        return new OpenAPI()
                .info(new Info().title("Product Service API Busycoder")
                        .description("This is the REST API for Product Service")
                        .version("v0.0.1")
                        .license(new License().name("Apache 2.0")))
                .externalDocs(new ExternalDocumentation()
                        .description("You can refer to the Product Service Wiki Documentation")
                        .url("https://product-service-dummy-url.com/docs"));
    }
}

Step 3: customization of path
--------------------------------
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs


Step 4: explore swagger endpoint
http://localhost:8080/swagger-ui/index.html
http://localhost:8080/api-docs


Step 5: replicate same stuff in other services

order service:
------------
http://localhost:8081/swagger-ui/index.html
http://localhost:8081/api-docs


inventory service:
------------
http://localhost:8082/swagger-ui/index.html
http://localhost:8082/api-docs




Aggrigate documentation and by pass security for documentation:
-----------------------------------------------------------

Step 1: add swagger dep to the gateway project
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>2.5.0</version>
        </dependency>
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
            <version>2.5.0</version>
        </dependency>


Step 2:
@Configuration
public class OpenAPIConfig {

    @Bean
    public OpenAPI productServiceAPI() {
        return new OpenAPI()
                .info(new Info().title("Gateway Service API Busycoder")
                        .description("This is the REST API for Gateway Service")
                        .version("v0.0.1")
                        .license(new License().name("Apache 2.0")))
                .externalDocs(new ExternalDocumentation()
                        .description("You can refer to the Gateway Service Wiki Documentation")
                        .url("https://Gateway-service-dummy-url.com/docs"));
    }
}

Step 3: configure aggrigate endpoint for all services
	so that all must be visible as drop down list
	
	
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs

springdoc.swagger-ui.urls[0].name=Product Service
springdoc.swagger-ui.urls[0].url=/aggregate/product-service/v3/api-docs
springdoc.swagger-ui.urls[1].name=Order Service
springdoc.swagger-ui.urls[1].url=/aggregate/order-service/v3/api-docs
springdoc.swagger-ui.urls[2].name=Inventory Service
springdoc.swagger-ui.urls[2].url=/aggregate/inventory-service/v3/api-docs

Step 3: now we have to create routes so that whenever brower is sending req to 
/aggregate/product-service/v3/api-docs
request must be send to product documentation




import static org.springframework.cloud.gateway.server.mvc.filter.FilterFunctions.setPath;
import static org.springframework.cloud.gateway.server.mvc.handler.GatewayRouterFunctions.route;

@Configuration
public class Routes {

    @Value("${product.service.url}")
    private String productServiceUrl;
	
    @Value("${order.service.url}")
    private String orderServiceUrl;
	
    @Value("${inventory.service.url}")
    private String inventoryServiceUrl;
	
	
    @Bean
    public RouterFunction<ServerResponse> productServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("product_service_swagger")
                .route(RequestPredicates.path("/aggregate/product-service/v3/api-docs"),
                        HandlerFunctions.http("http://localhost:8080"))
                                .filter(setPath("/api-docs"))
                                .build();
    }

    @Bean
    public RouterFunction<ServerResponse> orderServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("order_service_swagger")
                .route(RequestPredicates.path("/aggregate/order-service/v3/api-docs"),
                        HandlerFunctions.http("http://localhost:8081"))
                .filter(setPath("/api-docs"))
                .build();
    }


    @Bean
    public RouterFunction<ServerResponse> inventoryServiceSwaggerRoute() {
        return GatewayRouterFunctions.route("inventory_service_swagger")
                .route(RequestPredicates.path("/aggregate/inventory-service/v3/api-docs"),
                        HandlerFunctions.http("http://localhost:8082"))
                .filter(setPath("/api-docs"))
                .build();
    }

}

Step 4: now try
http://localhost:9000/swagger-ui/index.html

but we need to by pass security for swagger endpoints
we need to permit endpoint without security ...

@Configuration
public class SecurityConfig {

    private final String[] freeResourceUrls = {"/swagger-ui.html", "/swagger-ui/**", "/v3/api-docs/**",
            "/swagger-resources/**", "/api-docs/**", "/aggregate/**", "/actuator/prometheus"};

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity.authorizeHttpRequests(authorize -> authorize
                        .requestMatchers(freeResourceUrls)
                        .permitAll()
                        .anyRequest().authenticated())
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()))
                .build();
    }
}


Step 5: now try
http://localhost:9000/swagger-ui/index.html




Applying Circuit breaker
===========================
Applying circuitbreakers to API gateway:

step 1: add dep
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
        </dependency>
		
		
step 2: configure circuit breaker in the project
----------------------------------------------
# Actuator Endpoints
management.health.circuitbreakers.enabled=true
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

#Resilinece4j Properties
resilience4j.circuitbreaker.configs.default.registerHealthIndicator=true
resilience4j.circuitbreaker.configs.default.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.configs.default.slidingWindowSize=10
resilience4j.circuitbreaker.configs.default.failureRateThreshold=50
resilience4j.circuitbreaker.configs.default.waitDurationInOpenState=5s
resilience4j.circuitbreaker.configs.default.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.configs.default.automaticTransitionFromOpenToHalfOpenEnabled=true
resilience4j.circuitbreaker.configs.default.minimum-number-of-calls=5

#Resilience4J Timeout Properties
resilience4j.timelimiter.configs.default.timeout-duration=3s

#Resilience4J Retry Properties
resilience4j.retry.configs.default.max-attempts=3
resilience4j.retry.configs.default.wait-duration=2s


Step 3: define fallback routes:
------------------------------
@Configuration
public class Routes {
    @Bean
    public RouterFunction<ServerResponse> fallbackRoute() {
        return route("fallbackRoute")
                .GET("/fallbackRoute", request -> ServerResponse.status(HttpStatus.SERVICE_UNAVAILABLE)
                        .body("Service Unavailable, please try again later"))
                .build();
    }
}

Step 4: configure this routes for all communication:
-----------------------------------------------------
@Configuration
public class Routes {
    @Bean
    public RouterFunction<ServerResponse> productServiceRoute() {
        return GatewayRouterFunctions.route("product_service")
                .route(RequestPredicates.path("/api/product"), HandlerFunctions.http("http://localhost:8080))
                .filter(CircuitBreakerFilterFunctions.circuitBreaker("productServiceCircuitBreaker",
                        URI.create("forward:/fallbackRoute")))
                .build();
    }
	//.......
	//.........
}

Step 5: now observe circuit breaker
http://localhost:9000/actuator/health


Step 6: applying circuit breaker to the order service
------------------------------------------------------

step 6 a: add dependencies
-------------------------
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-resilience4j</artifactId>
        </dependency>
		
	
	
step 6 b: add configuration
-------------------------

management.health.circuitbreakers.enabled=true
management.endpoints.web.exposure.include=*
management.endpoint.health.show-details=always

#Resilinece4j Properties
resilience4j.circuitbreaker.instances.inventory.registerHealthIndicator=true
resilience4j.circuitbreaker.instances.inventory.event-consumer-buffer-size=10
resilience4j.circuitbreaker.instances.inventory.slidingWindowType=COUNT_BASED
resilience4j.circuitbreaker.instances.inventory.slidingWindowSize=5
resilience4j.circuitbreaker.instances.inventory.failureRateThreshold=50
resilience4j.circuitbreaker.instances.inventory.waitDurationInOpenState=5s
resilience4j.circuitbreaker.instances.inventory.permittedNumberOfCallsInHalfOpenState=3
resilience4j.circuitbreaker.instances.inventory.automaticTransitionFromOpenToHalfOpenEnabled=true
resilience4j.circuitbreaker.instances.inventory.minimum-number-of-calls=5

#Resilience4J Timeout Properties
resilience4j.timelimiter.instances.inventory.timeout-duration=3s

#Resilience4J Retry Properties
resilience4j.retry.instances.inventory.max-attempts=3
resilience4j.retry.instances.inventory.wait-duration=5s

step 6 c: add configuration
-------------------------
@FeignClient(value = "inventory", url = "${inventory.url}", fallback = InventoryClientImpl.class)
public interface InventoryClient {
    @RequestMapping(method = RequestMethod.GET, value = "/api/inventory")
    boolean isInStock(@RequestParam String skuCode, @RequestParam Integer quantity);
}

@Service
public class InventoryClientImpl implements InventoryClient {
    @Override
    public boolean isInStock(String skuCode, Integer quantity) {
        return true;
    }
}




Kafka integration
=================
 //send the message to the kafka topic once the order is placed
 and notifications service recive the message and send a email to the customer
 
 
Step 1: update docker compose file
------------------------------------
 zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    hostname: zookeeper
    container_name: zookeeper
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000

  broker:
    image: confluentinc/cp-kafka:7.5.0
    container_name: broker
    ports:
      - "9092:9092"
      - "29092:29092"
    depends_on:
      - zookeeper
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://broker:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1

  schema-registry:
    image: confluentinc/cp-schema-registry:7.5.0
    hostname: schema-registry
    container_name: schema-registry
    depends_on:
      - broker
    ports:
      - "8085:8081"
    environment:
      SCHEMA_REGISTRY_HOST_NAME: schema-registry
      SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS: 'broker:29092'
      SCHEMA_REGISTRY_LISTENERS: http://schema-registry:8081
  kafka-ui:
    container_name: kafka-ui
    image: provectuslabs/kafka-ui:latest
    ports:
      - "8086:8080"
    depends_on:
      - broker
    environment:
      KAFKA_CLUSTERS_NAME: local
      KAFKA_CLUSTERS_BOOTSTRAPSERVERS: broker:29092
      #      KAFKA_CLUSTERS_SCHEMAREGISTRY: http://schema-registry:8081
      DYNAMIC_CONFIG_ENABLED: 'true'
	  
	  

step 2: add dependency to the order application
-----------------------------------
       <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
		
	
step 3: mentioned prop in application.properties file
------------------------------------------------------	
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.template.default-topic=order-placed
spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer
spring.kafka.producer.value-serializer=org.springframework.kafka.support.serializer.JsonSerializer


step 4: create POJO to hold the message
--------------------------------------
@Data
@NoArgsConstructor
public class OrderPlacedEvent {
    private String orderNumber;
    private String customerEmail;
}


step 4: send message 
---------------------
{

    private final OrderService orderService;
    private final InventoryClient inventoryClient;

    private final KafkaTemplate<String, OrderPlacedEvent> kafkaTemplate; // <key, value>

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public String placeOrder(@RequestBody OrderDto orderDto) {
        boolean isInStock = inventoryClient
                .isInStock(orderDto.getSkuCode(), orderDto.getQuantity());
        if (!isInStock) {
            throw new RuntimeException("Product is not in stock");
        }
        orderService.placeOrder(orderDto);
        //send the message to the kafka topic once the order is placed
        OrderPlacedEvent orderPlacedEvent = new OrderPlacedEvent();
        orderPlacedEvent.setOrderNumber(orderDto.getOrderNumber());
        orderPlacedEvent.setCustomerEmail(orderDto.getCustomerEmail());

        log.info("sending Order to Placed Event: {}", orderPlacedEvent);
        kafkaTemplate.send("order-placed", orderPlacedEvent);
        log.info("End Order to Placed Event: {}", orderPlacedEvent);
        return "Order Placed Successfully";
    }
}

step 5: go to http://localhost:8086/ ie UI for apache kafka
-------------------------------------------------------
http://localhost:8086/

Configure cluster:
-----------------
cluster name : localhost
broker server: broker
port : 29092

Now validate and enter 
go to dashboard and check Topics



step 6: now we need to create consumer service
ie notifications service (port 8083)
----------------------------------------------
 step 1: choose spring mvc , kafka dep, actuator, lombok
 
 step 2: add Dto into same package "com.orders.event"
 
	 @Data
	@NoArgsConstructor
	public class OrderPlacedEvent {
		private String orderNumber;
		private String customerEmail;;
	}

step 3: put kafka consumer properties in application.properties file

# Kafka Consumer Properties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.consumer.group-id=notification-service
spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer
spring.kafka.consumer.value-deserializer=org.springframework.kafka.support.serializer.JsonDeserializer
spring.kafka.consumer.properties.spring.json.trusted.packages=*

step 4: Write consumer to consume message send by order asynchronously

@Service
@Slf4j
public class NotificationService {

    @KafkaListener(topics = "order-placed", groupId = "notification-service")
    public void sendNotification(OrderPlacedEvent orderPlacedEvent) {
        System.out.println(orderPlacedEvent);
        log.info("Sending notification to customer {} for order {}",
                orderPlacedEvent.getCustomerEmail(), orderPlacedEvent.getOrderNumber());
    }
}

		
		
Step 6: Configure fake email server account at 
https://mailtrap.io/ and send email to the customer
		
		
		



Observablility using graphan stack
==================================

What is Observability?
---------------------------
	Observability is the process of understanding the internal state of the application 
	with the help of different indicators such as Logs, Metrics, and Tracing information.

	Log matrix and traces
	------------------
	Log: application logs
	
	matrix: jvm statistics, thread count, Heap memory etc
	
	Traces: distributed tracking
		help to traces application flow from A -> B
		
		
	https://www.ibm.com/think/topics/observability



Grafana Stack comprises about 3 softwares:
----------------------------------------
	Grafana: 
		Tool that helps to monitor and visualize the metrics of our application.
		
		Users can visualize the metrics by building different dashboards and can use 
		different kinds of charts to visualize the metrics. 
		We can also configure alerts to be notified whenever a metric reaches a certain required threshold.

	Prometheus:
		Scraping matrix
		
		To collect metrics, we will be using Prometheus, 
		a metrics aggregation tool.

	Loki: 
			is a Log Aggregation tool that receives the logs from our application
			and indexes the logs to be visualized using Grafana.
			
			Loki: aggrigate logs of application for logging
			
			https://signoz.io/blog/loki-vs-elasticsearch/
			https://opsverse.io/2024/07/26/grafana-loki-vs-elk-stack-for-logging-a-comprehensive-comparison/

	Tempo: 
			Tempo: simpilar to zipkin to distributed tracing
			is used as a distributed tracing tool, which can track requests that span across different systems.
			



	We will see how to implement Observability for a sample loan processing 
	system built with Spring Boot 3 using the Grafana Stack
	
	
	
Step 1:Let's start with implementing logging in our application
---------------------------------------------------

Step 1.1: To send our application logs to Loki, we have to add the below 
dependency to the pom.xml of both loan-service and fraud-service.

 <dependency>
        <groupId>com.github.loki4j</groupId>
        <artifactId>loki-logback-appender</artifactId>
        <version>1.3.2</version>
    </dependency>
	
Step 1.2: define a logback-spring.xml file inside the src/main/resources which contains
 necessary information about how to structure our logs and where to send the logs 

logback-spring.xml
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/base.xml"/>
    <springProperty scope="context" name="appName" source="spring.application.name"/>
    <springProperty scope="context" name="lokiUrl" source="loki.url"/>

    <appender name="LOKI" class="com.github.loki4j.logback.Loki4jAppender">
        <http>
            <url>${lokiUrl}</url>
        </http>
        <format>
            <label>
                <pattern>application=${appName},host=${HOSTNAME},level=%level</pattern>
            </label>
            <message>
                <pattern>${FILE_LOG_PATTERN}</pattern>
            </message>
            <sortByTime>true</sortByTime>
        </format>
    </appender>

    <root level="INFO">
        <appender-ref ref="LOKI"/>
    </root>
</configuration>


Note: dont forget to mentioned in the application.properties file of each projects
-----------------------------------------------------------------------------------
loki.url=http://localhost:3100/loki/api/v1/push






Step 2: Metrics
	Metrics can be any kind of measurable information about our application like JVM statistics,
	 Thread Count, Heap Memory information, etc. To collect metrics of our application,
	 we need to first enable Spring Boot Actuator in our project by adding the below dependency:
	
step 2.1:
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		
step 2.2:
	To expose the metrics of our application, Spring Boot uses Micrometer to collect metrics, 
	and by adding the below dependency we can configure Micrometer to
	expose an endpoint that can be scraped by Prometheus.

		<dependency>
			<groupId>io.micrometer</groupId>
			<artifactId>micrometer-registry-prometheus</artifactId>
			<scope>runtime</scope>
		</dependency>
		
step 2.3:
The next step is to add some properties to our application.yml file.

management.endpoints.web.exposure.include=health, info, metrics, prometheus
management.metrics.distribution.percentiles-histogram.http.server.requests=true
management.observations.key-values.application=loan-service


step 2.4: put prometheus config in docker compose file

step 2.5: understand prometheus.yml file
	Under the global field, we defined the scrape and evaluation interval as 2s.
	In the scrape_configs section, we have many jobs, 
	one for prometheus, 
	and for each service. 
	
	Notice that to scrape the loan-service and fraud-detection services we defined the URL 
	of both the services and the metrics path as - /actuator/prometheus
	
	
	
Distributed Tracing using Tempo
---------------------------------
	Now let implement Distributed Tracing using Tempo. 
	
	NOte : Prior to Spring Boot 3, we used to add the Spring Cloud Sleuth dependency
	to add distributed tracing capabilities to our application, but from Spring Boot 3, 
	Spring Cloud Sleuth is no longer needed and this is replaced by the Micrometer Tracing Project.
	
	
Step 1.1: 
	To add the support, add the below dependencies:
	
		<dependency>
			<groupId>io.micrometer</groupId>
			<artifactId>micrometer-tracing-bridge-brave</artifactId>
		</dependency>
		<dependency>
			<groupId>io.zipkin.reporter2</groupId>
			<artifactId>zipkin-reporter-brave</artifactId>
		</dependency>
		
	Note: 
		micrometer-tracing-bridge-brave is the dependency that does all
		the magic and adds distributed tracing for our application. 
		
		Whereas zipkin-reporter-brave will export the tracing information to Tempo.
		
		We can also use other tracing implementation like OpenTelemetry -
		micrometer-tracing-bridge-otel dependency instead of 
		Brave - micrometer-tracing-bridge-brave
		
		
step 1.2: in order to trace the calls to the database
		<dependency>
			<groupId>net.ttddyy.observation</groupId>
			<artifactId>datasource-micrometer-spring-boot</artifactId>
			<version>1.0.1</version>
		</dependency>
		
	 step 1.3: apply @Observed on the repo layer
	 
	 step 1.4: define bean
	 
@Configuration
public class ObservationConfig {
	@Bean
	ObservedAspect observedAspect(ObservationRegistry registry) {
				return new ObservedAspect(registry);
			}
}

	step 1.5:it need 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>
		
		
	Micrometer Tracing will only send 10% of the traces it generates to Tempo, 
	just to avoid overwhelming it with a lot of requests. 
	We can set it to 100% by adding the below property to our application.yml file

	step 1.6:
		management.tracing.sampling.probability=1.0

	step 1.7:
		Configure Tempo using docker, by configure into  docker-compose.yml file
		
	step 1.8:
		 configure a file called tempo.yml file to store the necessary settings to be used in Tempo.
		 
		 
		 

Running Grafana
------------------------
	let run Grafana using Docker. 
	After all, this is what brings all the services like Tempo, Loki, and Prometheus together and
	visualizes the information produced by our services.
	
	step 1.1: configure graphana in docker compose file
	
	step 1.2: define the data sources from which it needs to gather the information to visualize, 
	for that let's create a file called datasources.yml
	
	
	
Now Explore and try to get desired output:
-----------------------------------------
http://localhost:3000

	Toggle menu ---> 'Explore'
		Under the dropdown select - 'Loki' and 
		run the query with your desired parameters, 
		e.g.: select the application label as - loan-service.

	

	

